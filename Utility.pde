import java.io.File;import org.apache.commons.io.FilenameUtils;import org.apache.commons.io.FileUtils;import java.awt.Toolkit; public PImage returnImage(ArrayList<String>PImagePathList ){									//Load a single image at this point instead of loading huge array in setup  memory problems 	Random Qground = new Random();	int _num  = nextIntInRange(0, PImagePathList.size()-1, Qground);	PImage img =loadImage(PImagePathList.get(_num));	//tint(255, imgAlpha );  // Apply transparency without changing color	//image(stripesImage,0,0);	// tint(255, 255);  // Reset  transparency without changing color */	return img;} public PShape returnShape(ArrayList<String>PImagePathList ){									//Load a single image at this point instead of loading huge array in setup  memory problems 	Random Qground = new Random();	int _num  = nextIntInRange(0, PImagePathList.size()-1, Qground);	PShape returnShape =loadShape(PImagePathList.get(_num));	//tint(255, imgAlpha );  // Apply transparency without changing color	//image(stripesImage,0,0);	// tint(255, 255);  // Reset  transparency without changing color */	return returnShape;} public static String getFileName(String FilePath) {	File file = new File(FilePath);	String fileName = file.getName();	// String basename = FilenameUtils.getBaseName(fileName);	return fileName;}public static String getFileNameWithoutExtension(String FilePath) {	File file = new File(FilePath);	String fileNameWithOutExt = FilenameUtils.removeExtension(file.getName());	// String basename = FilenameUtils.getBaseName(fileName);	return fileNameWithOutExt;}/* .......................................................writeBooleanValues()......................................... */public void writeBooleanValues() {	println(" ..............Initial Boolean values  and Global Variables............................ ");	println("write_images = "+write_images);	println("two_images = "+ two_images );	println("show_2_chosen_images = "+ show_2_chosen_images);	println("use_random_chosen_images = "+ use_random_chosen_images);	println(" ................Show data .......................... ");	println("show_data = "+ show_data);	println("show_particle_statistics = "+show_particle_statistics );	println("dots_crosses  = "+ dots_crosses);	println("show_mousewheel  = "+show_mousewheel );	println(" ................Image Control .......................... ");	println("changeDirection  = "+ changeDirection);	println("kb_image_trail = "+ kb_image_trail);		println("save_big_graphic = "+save_big_graphic );	println("show_rectangles  = "+ show_rectangles);	println("HSB_on  = "+ HSB_on);	println("frameRate  = " + framerate);	println("time_stamp_dir  = " + time_stamp_dir);	println("number of particles in system  = " + num_particles);	println(" trace_color_default           = "+ hex(trace_color_default ,6));	println("use_random_trace_fill_1           = "+use_random_trace_fill_1 );	println("use_random_trace_fill           = "+use_random_trace_fill );	/*	println("           = "+ );				println("           = "+ );				println("           = "+ );				println("           = "+ );				println("           = "+ );				println("           = "+ ); */				}/* ........................................................... Random change of fills ................................. *//* Used in Particles.pde */public color returnTraceRandomColor(){	trace_alpha = random(0,150);	trace_red = random(0,255);	trace_green =random(0,255);	trace_blue   =random(0,255);	trace_color = color(trace_red,trace_green,trace_blue,trace_alpha); 		return trace_color;}/* Used in Particles.pde */public color returnFillRandomColor(){	fill_alpha = random(0,255);	fill_red = random(0,255);	fill_green =random(0,255);	fill_blue   =random(0,255);	fill_color= color ( fill_red,fill_green,fill_blue,fill_alpha );	return fill_color;}public void toggleRandomTraceFill() {	/*   These variables are defined global */	if(use_random_trace  == false){use_random_trace  = true;		println( "random trace color = on");  // lower case		//break;	} else {use_random_trace  = false;		println( "random trace color = off");  		//break;	}	}//println("(Urility.pde changeRandomFill()...New fill color = " + hex(newColor,6 ));//}
/* Randiom cgange of fill using UP and Down Arrows    see javaKeyControls.pde */public color changeRandomFill() {	/*   These variables are defined global */
	fill_red = random(0,255); 	fill_green =random(0,150); /* Reduce green */	fill_blue=random(0,255); 	color newColor  = color (fill_red,fill_green,fill_blue);  /*  println(hex(c, 6));  // Prints "FFCC00" */	if(show_keysdata) {		println("Utility.pde..changeRandomFill()..fill_red  = " + fill_red );		println("Utility.pde..changeRandomFill()..fill_green = " +fill_green );		println("Utility.pde..changeRandomFill()..fill_blue = " + fill_blue);		// println(hex(c, 6)	}	//println("(Urility.pde changeRandomFill()...New fill color = " + hex(newColor,6 ));
	return newColor;}/* Randiom cgange of fill using UP and Down Arrows    see javaKeyControls.pde */public color changeRandomFill1() {	/*   These variables are defined global */	/* random(high)random(low, high) */	float fill_red = random(0,255);      		float fill_green =random(0,255); 	float fill_blue= random(0,255); 	color newColor  = color (fill_red,fill_green,fill_blue);  /*  println(hex(c, 6));  // Prints "FFCC00" */	println("(Utility.pde).. changeRandomFill()...New fill color = " + hex(newColor,6 ));	return newColor;}public void changeRandomImageA() {	/* choose image for this run      r_1,r_2 Global*/	//println( "..........changeRandomImage - selecting two new images from the image pool...............");	Random Qground = new Random();	r_1  = nextIntInRange(0, PImagePathList.size()-1, Qground);	Random Pground = new Random();	r_2  = nextIntInRange(0, PImagePathList.size()-1, Pground);		if(r_1==r_2 && r_1 != PImagePathList.size())	{r_2 = r_1 +1;}	else { Random Sground = new Random(); 		r_2  = nextIntInRange(0, PImagePathList.size()-1, Sground);}		img_random_1 = loadImage( PImagePathList.get(r_1));	img_random_2 = loadImage( PImagePathList.get(r_2));	println( "Two images chosen for this run img_1 = "+ imageFileNames.get(r_1) +"   img_2 = "+ imageFileNames.get(r_2) );	println( "Total number of images in image pool -- img_length = "+PImagePathList.size());	println( "(Utility.pde)....changeRandomImage1...............");}/* Used to change images on the fly using numbers 1,2,3   see javakeyControls.pde*/public String  changeRandomImage3(){	Random Qground = new Random();       Qground.setSeed(System.currentTimeMillis() );		r_3  = nextIntInRange(0, PImagePathList_2.size()-1, Qground);		img_random_3 = loadImage( PImagePathList_2.get(r_3));		return getFileName(PImagePathList.get(r_3));}public String  changeRandomImage2(){	Random Qground = new Random();       Qground.setSeed(System.currentTimeMillis() );		r_2  = nextIntInRange(0, PImagePathList_1.size()-1, Qground);		img_random_2 = loadImage( PImagePathList_1.get(r_2));		return getFileName(PImagePathList.get(r_2));}public String  changeRandomImage1(){	Random Qground = new Random();       Qground.setSeed(System.currentTimeMillis() );		r_1  = nextIntInRange(0, PImagePathList.size()-1, Qground);		img_random_1 = loadImage( PImagePathList.get(r_1));		return getFileName(PImagePathList.get(r_1));}/* Change all images using key c */
public void changeRandomImage() {		Random Qground = new Random();		Qground.setSeed(System.currentTimeMillis());		r_1  = nextIntInRange(0, PImagePathList.size()-1, Qground);		Qground.setSeed(System.currentTimeMillis() +18);		r_2  = nextIntInRange(0, PImagePathList_1.size()-1, Qground);		Qground.setSeed(System.currentTimeMillis() +36);		r_3  = nextIntInRange(0, PImagePathList_2.size()-1, Qground);				/* Can be assigned in Particle.pde ??*/		img_random_1 = loadImage( PImagePathList.get(r_1));		img_random_2 = loadImage( PImagePathList_1.get(r_2));		img_random_3 = loadImage( PImagePathList_2.get(r_3));	println( "(Utility.pde)....changeRandomImage............... run img_1 = "+ imageFileNames.get(r_1)+"  ["+  r_1 +"]   img_2 = "+ imageFileNames.get(r_2)+"  ["+  r_2+"]" );}/* .......................................................getNumberFilesInDirectory()   from scribble  ....................................................................... */int getNumberFilesInDirectory(String input_file_directory,String file_extension){	int number_files =0;	ArrayList <File> file_kb = new ArrayList();	File[] fileList = new File(input_file_directory).listFiles();	for(File file : fileList){		if(file.isFile() & (file.getName()).endsWith("."+file_extension)){			//println("....................."+file);			//files_kb.add(file.getName());			// file_kb.add(file);			number_files++;			/*      for (int ii=0;ii < files_kb.size();ii++)		{		println( " files = " + file_kb.get(ii).getName()             );		println( " path = " + file_kb.get(ii).getPath()             );		}	*/  		}}	return number_files;}/* .......................................................getNumberFilesInDirectory() ..END....................................................................... *//* ............................................................................................................................................................. *//*  http://mojones.net/radial-transparent-gradients-in-processingorg.html */void radialGradient(float x, float y, int c, int size) {	PGraphics pg = createGraphics(size, size, JAVA2D);	pg.beginDraw();	pg.background(30, 0);	int halfsize = size / 2;	for (int i = 0; i <= size; i += 1) {		for (int j = 0; j <= size; j += 1) {			// calculate distance to center			//float distance = (float) Math.hypot(i - size / 2, j - size / 2) / (size / 2);			//float distance = (float) sqrt(sq(i-size/2) + sq(j-size/2)) / (size/2);			float xDist = i - halfsize;			float yDist =  j - halfsize;			float distance = (float) Math.sqrt(xDist*xDist + yDist*yDist) / halfsize;			float scale = 1 - distance;			if (scale < 0 ) {				scale = 0;			}			float transparency = 255 * (scale * scale);			int thisColour = color(c, int(transparency));			pg.set(i, j, thisColour);		}	}	pg.endDraw();	imageMode(CENTER);	image(pg, x, y);}/* ..............................drawGradient.......................... *//* void drawGradient(float x, float y) {int radius = dim/2;float h = random(0, 360);for (int r = radius; r > 0; --r) {	fill(h, 90, 90);	ellipse(x, y, r, r);	h = (h + 1) % 360;}} */void saveTransparentCanvas(final color bg, final String name) {	final PImage canvas = get();	canvas.format = ARGB;	final color p[] = canvas.pixels, bgt = bg & ~#000000;	for (int i = 0; i != p.length; ++i)  if (p[i] == bg)  p[i] = bgt;	canvas.updatePixels();	canvas.save(dataPath(name ));  // for tree program	/* canvas.save(dataPath(name + nf(frameCount, 4) + ".png")); */}/* Exit program with comment */public void exitWithComment(String comment){	println("Program exit: = " + comment);	exit();}/* http://www.openprocessing.org/sketch/39787 */
public void makeTubPattern(int num)    /* int num = 60; //number of circles */{	float[] y = new float[num]; //seeting up the array	smooth(8);	for (int i = 0; i < y.length; i++) {		y[i] = random(100); //width of line the ellipses come down in	}	stroke(random(255),random(255),random(255));	noFill();	for (int i = 0; i<y.length;i++) {		ellipse((2*width/y.length) * i, y[i], 50, 15);		y[i] = y[i]+1; //drags the ellipses down		if (y[i] > height) y[i] = 0;	}
}    /* End public void makeTubPattern(num)  */ public void addComplexFill(){	float tempval;	tempval = screen_alpha;	if(tempval>=0.0&&tempval<=255 ){tempval= tempval+10;}  /*CONTROLS SCREEN  OVERLAY  ALPHA*/	if(tempval<=255&&tempval>=0){screen_alpha =tempval;}	else if(tempval>=255) {screen_alpha = 255;}	else if(tempval<=0) {screen_alpha = 0;}	/* Change color of fill */	fill(changeRandomFill(),(int)screen_alpha); 	rect(0,0,width,height);  /* DEFINE RECTANGLE AND FILL IT*/	screen_alpha = 25;    /* Override for this function */	pushMatrix();	translate(width/2, height/2);	rotate(PI/3.0);	fill(changeRandomFill(),(int)screen_alpha); 			rect(0,0,width/2,height/2); 		//quad(0, 0, width/2, height/2, 69, 63, 30, 76);	ellipse(0, 0, width/2, width/2);	popMatrix();	/* 	Tryout adding stripes */	/* 							if(use_stripes) {																//Load a single image at this point instead of loading huge array in setup  memory problems 								Random Qground = new Random();								int stripesfile_num  = nextIntInRange(0, PImageStripesPathList.size()-1, Qground);								stripesImage =loadImage(PImageStripesPathList.get(stripesfile_num));								tint(255, 150);  // Apply transparency without changing color								image(stripesImage,0,0);								tint(255, 255);  // Reset  transparency without changing color   								} 							//PImage */		/* 	Tryout adding stripes --  See utility.pde */		/* 						if(use_stripes) {							stripesImage =	returnImage(PImageStripesPathList); 			tint(255, 150 );  // Apply transparency without changing color			image(stripesImage,0,0);				   			tint(255, 255);  // Reset  transparency without changing color 		}		*/		fill(changeRandomFill(),(int)screen_alpha); 			rect(width/2,height/2,width,height); 				fill(changeRandomFill(),(int)screen_alpha); 	rect(width/2,height/2,width,0);  		fill(changeRandomFill(),(int)screen_alpha); 			rect(width/2,height/2,0,height); 		fill(changeRandomFill(),(int)screen_alpha); 	rect(width/2,height/2,width/4,height/4);  /* DEFINE RECTANGLE AND FILL IT*/	if(show_keysdata) {		println( "width*scale_factor= "+width*scale_factor);		println("height*scale_factor = " +height*scale_factor );		println( " UP screen_alpha = "+screen_alpha);}	//println("UP = "+keyCode);}public void addComplexFill2 (){	float tempval;	tempval = screen_alpha;	if(tempval>=0.0&&tempval<=255 ){tempval= tempval-10;}  /*CONTROLS SCREEN  OVERLAY  ALPHA*/	if(tempval<=255&&tempval>=0){screen_alpha =tempval;}	else if(tempval>=255) {screen_alpha = 255;}	else if(tempval<=0) {screen_alpha = 0;}	/* Change color of fill   Utility.pde*/	//color newColor = changeRandomFill();	fill(changeRandomFill(),(int)screen_alpha); 	//fill(newColor,(int)screen_alpha); 	//fill(100,20,0,(int)trace_alpha); // rgb alpha	//rect(0,0,width*scale_factor,height*scale_factor);  /* DEFINE RECTANGLE AND FILL IT*/	rect(0,0,width,height);  /* DEFINE RECTANGLE AND FILL IT*/	//rect(width/2,height/2,width,height);	if(show_keysdata) {		println( "width*scale_factor= "+width*scale_factor);		println( "DOWN screen_alpha= "+screen_alpha);}}public void turnTraceOnOff(boolean trace_on){if(write_images  == false){write_images  = true;			println( "images on");  					} if(write_images  == true){write_images  = false;			println( "images off");  					}	}public void turnRectanglesOnOff(){if(show_rectangles  == false){show_rectangles  = true;			println( "rectangles on");  					} if(show_rectangles  == true){show_rectangles  = false;			println( "rectangles off");  					}	}